<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æœ¬åœ°éŸ³é¢‘å‰ªè£å·¥å…·ï½œiPad å…¼å®¹ + MP3 å¯¼å‡º</title>
  <style>
    :root{--bg:#0f172a;--panel:#111827;--muted:#6b7280;--accent:#22c55e;--accent-2:#3b82f6;--text:#e5e7eb;--danger:#ef4444}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1020,#0a0f1f);color:var(--text);font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Noto Sans CJK SC","Microsoft Yahei",sans-serif}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    .card{background:rgba(255,255,255,0.04);backdrop-filter: blur(6px);border:1px solid rgba(255,255,255,.08);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .head{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.08)}
    .head h1{font-size:18px;margin:0;font-weight:700}
    .controls{display:flex;flex-wrap:wrap;gap:8px}
    input[type=file]{display:none}
    .btn{appearance:none;border:none;border-radius:12px;padding:10px 14px;color:#fff;background:#1f2937;cursor:pointer;transition:.2s ease;display:inline-flex;gap:8px;align-items:center}
    .btn:hover{filter:brightness(1.15)}
    .btn.primary{background:linear-gradient(180deg,var(--accent),#179d48)}
    .btn.blue{background:linear-gradient(180deg,var(--accent-2),#2563eb)}
    .btn.danger{background:linear-gradient(180deg,var(--danger),#b91c1c)}
    .btn.ghost{background:transparent;outline:1px solid rgba(255,255,255,.15)}
    .btn:disabled{opacity:.55;cursor:not-allowed}
    .body{padding:16px}
    .canvas-wrap{position:relative;border-radius:14px;overflow:hidden;border:1px solid rgba(255,255,255,.08);background:#0a0f1c}
    canvas{display:block;width:100%;height:180px}
    .timeline{position:absolute;inset:0;pointer-events:none}
    .info{display:grid;grid-template-columns: repeat(6,minmax(0,1fr));gap:12px;margin-top:12px}
    .stat{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px}
    .stat small{display:block;color:var(--muted);font-size:12px}
    .stat b{font-size:16px}
    .footer{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between;margin-top:14px}
    .range{display:flex;gap:8px;align-items:center}
    input[type=range]{width:200px}
    .kbd{font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,monospace;color:#cbd5e1;background:#0b1220;border:1px solid rgba(255,255,255,.1);padding:3px 6px;border-radius:8px}
    .hint{color:#a1a1aa}
    .progress{position:absolute;left:0;top:0;height:100%;width:0;background:rgba(56,189,248,.08);pointer-events:none}
    .sel{position:absolute;top:0;height:100%;left:0;width:0;background:rgba(34,197,94,.18);outline:1px dashed rgba(34,197,94,.9);pointer-events:none}
    .loading{display:none;gap:8px;align-items:center;color:#93c5fd}
    .loading.on{display:inline-flex}
    .dot{width:8px;height:8px;border-radius:50%;background:#60a5fa;animation:b 1s infinite}
    .dot:nth-child(2){animation-delay:.15s}.dot:nth-child(3){animation-delay:.3s}
    @keyframes b{0%{transform:translateY(0)}50%{transform:translateY(-4px)}100%{transform:translateY(0)}}
  </style>
</head>
<body>
  <div class="wrap card">
    <div class="head">
      <h1>æœ¬åœ°éŸ³é¢‘å‰ªè£å·¥å…· <span style="opacity:.6">ï½œiPad å…¼å®¹ & MP3 å¯¼å‡º</span></h1>
      <div class="controls">
        <label class="btn blue" for="fileInput">ğŸ“‚ è½½å…¥éŸ³é¢‘</label>
        <input id="fileInput" type="file" accept="audio/*,.mp3,audio/mpeg,.m4a" />
        <button id="playBtn" class="btn" disabled>â–¶ï¸ æ’­æ”¾/æš‚åœ</button>
        <button id="stopBtn" class="btn ghost" disabled>â¹ï¸ åœæ­¢</button>
        <button id="loopBtn" class="btn ghost" disabled>ğŸ” å¾ªç¯å…³</button>
        <button id="fitBtn" class="btn ghost" disabled>ğŸ§­ é€‚é…æ³¢å½¢</button>
        <button id="zoomInBtn" class="btn ghost" disabled>â• æ”¾å¤§</button>
        <button id="zoomOutBtn" class="btn ghost" disabled>â– ç¼©å°</button>
        <button id="resetSelBtn" class="btn ghost" disabled>ğŸ§¹ æ¸…é™¤é€‰åŒº</button>
        <button id="exportWavBtn" class="btn primary" disabled>â¬‡ï¸ å¯¼å‡ºé€‰æ®µ (WAV)</button>
        <button id="exportMp3Btn" class="btn ghost" disabled>ğŸ§ å¯¼å‡ºé€‰æ®µ (MP3)</button>
      </div>
    </div>
    <div class="body">
      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="wave"></canvas>
        <div class="progress" id="playhead"></div>
        <div class="sel" id="selection"></div>
        <canvas class="timeline" id="grid"></canvas>
      </div>
      <div class="info">
        <div class="stat"><small>æ–‡ä»¶å</small><b id="fileName">â€”</b></div>
        <div class="stat"><small>é‡‡æ ·ç‡</small><b id="sampleRate">â€”</b></div>
        <div class="stat"><small>å£°é“æ•°</small><b id="channels">â€”</b></div>
        <div class="stat"><small>æ—¶é•¿</small><b id="duration">â€”</b></div>
        <div class="stat"><small>é€‰æ‹©å¼€å§‹</small><b id="selStart">â€”</b></div>
        <div class="stat"><small>é€‰æ‹©ç»“æŸ</small><b id="selEnd">â€”</b></div>
      </div>
      <div class="footer">
        <div>
          <div class="hint">æç¤ºï¼šæ‹–åŠ¨æ³¢å½¢å³å¯æ¡†é€‰ï¼›<span class="kbd">Space</span> æ’­æ”¾/æš‚åœï¼Œ<span class="kbd">Ctrl/Cmd+E</span> å¯¼å‡ºé€‰æ®µã€‚</div>
          <div id="loading" class="loading" style="margin-top:6px"><span class="dot"></span><span class="dot"></span><span class="dot"></span><span style="margin-left:6px">é•¿éŸ³é¢‘/MP3 åœ¨ iPad ä¸Šå°†é™éŸ³è½¬ç ï¼Œè€—æ—¶â‰ˆéŸ³é¢‘æ—¶é•¿</span></div>
        </div>
        <div class="range">
          <span>ç¼©æ”¾ï¼š</span>
          <input id="zoomRange" type="range" min="1" max="10" step="1" value="1" disabled />
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const waveCanvas = document.getElementById('wave');
  const gridCanvas = document.getElementById('grid');
  const wrap = document.getElementById('canvasWrap');
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const loopBtn = document.getElementById('loopBtn');
  const exportWavBtn = document.getElementById('exportWavBtn');
  const exportMp3Btn = document.getElementById('exportMp3Btn');
  const fitBtn = document.getElementById('fitBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetSelBtn = document.getElementById('resetSelBtn');
  const zoomRange = document.getElementById('zoomRange');
  const playheadEl = document.getElementById('playhead');
  const selEl = document.getElementById('selection');
  const loading = document.getElementById('loading');

  const fileNameEl = document.getElementById('fileName');
  const srEl = document.getElementById('sampleRate');
  const chEl = document.getElementById('channels');
  const durEl = document.getElementById('duration');
  const selStartEl = document.getElementById('selStart');
  const selEndEl = document.getElementById('selEnd');

  let audioCtx; // AudioContext
  let buffer;   // AudioBuffer
  let srcNode;  // BufferSourceNode
  let playing = false;
  let loop = false;

  let zoom = 1;      // 1..10
  let peaks = [];    // downsampled peaks

  let selection = {active:false, start:0, end:0}; // seconds

  const dpr = Math.max(1, window.devicePixelRatio || 1);

  const LONG_FILE_BYTE_THRESHOLD = 80 * 1024 * 1024; // 80MB ä»¥ä¸Šèµ°é•¿éŸ³é¢‘æ¨¡å¼
  const LONG_FILE_DURATION_THRESHOLD = 2 * 3600; // >2å°æ—¶

  function fmt(t){
    if (!isFinite(t)) return 'â€”';
    const sign = t < 0 ? '-' : '';
    t = Math.max(0, t);
    const m = Math.floor(t/60);
    const s = Math.floor(t%60);
    const ms = Math.floor((t*1000)%1000);
    return `${sign}${m}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
  }

  function enableUI(enabled){
    [playBtn, stopBtn, loopBtn, exportWavBtn, exportMp3Btn, fitBtn, zoomInBtn, zoomOutBtn, resetSelBtn, zoomRange].forEach(b=>b.disabled=!enabled);
  }
  function showLoading(on){ loading.classList.toggle('on', !!on); }

  function resize(){
    const rect = wrap.getBoundingClientRect();
    [waveCanvas, gridCanvas].forEach(cv=>{
      cv.width = Math.floor(rect.width * dpr);
      cv.height = Math.floor(180 * dpr);
      cv.style.width = rect.width + 'px';
      cv.style.height = '180px';
    });
    draw();
  }
  window.addEventListener('resize', resize);

  // ===== iOS/Safari MP3 & é•¿éŸ³é¢‘å…œåº•ï¼šå¤±è´¥æˆ–è¿‡å¤§åˆ™ç”¨ <audio> + MediaRecorder å®æ—¶è½¬ç  =====
  async function decodeArrayBufferWithFallback(arrBuf, ctx){
    try{ return await ctx.decodeAudioData(arrBuf.slice(0)); }
    catch(e1){
      return await new Promise((resolve, reject)=>{
        try{ ctx.decodeAudioData(arrBuf.slice(0), resolve, reject); }
        catch(e2){ reject(e2); }
      });
    }
  }

  async function transcodeViaMediaRecorderAndBuildPeaks(file, ctx){
    if (!('MediaRecorder' in window)) throw new Error('æ­¤æµè§ˆå™¨ä¸æ”¯æŒ MediaRecorder å…œåº•ã€‚');
    showLoading(true);
    const audioEl = new Audio(); audioEl.preload='auto'; audioEl.muted = true;
    const url = URL.createObjectURL(file); audioEl.src = url;

    const dest = ctx.createMediaStreamDestination();
    const src = ctx.createMediaElementSource(audioEl);
    src.connect(dest); src.connect(ctx.destination);

    // é‡‡æ ·æ³¢å½¢ï¼šé€šè¿‡ AnalyserNode å®æ—¶é‡‡æ ·ï¼Œç´¯ç§¯æˆä½åˆ†è¾¨ç‡å³°å€¼ï¼ˆé¿å…ä¸€æ¬¡æ€§è§£ç å å†…å­˜ï¼‰
    const analyser = ctx.createAnalyser(); analyser.fftSize = 1024; src.connect(analyser);
    const timeData = new Float32Array(analyser.fftSize);

    let mime = '';
    try{
      if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/mp4')) mime='audio/mp4';
      else if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm')) mime='audio/webm';
    }catch(_){ mime=''; }

    const chunks=[]; const rec = mime? new MediaRecorder(dest.stream,{mimeType:mime}) : new MediaRecorder(dest.stream);
    rec.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };

    if (ctx.state==='suspended'){ try{ await ctx.resume(); }catch(_){} }

    // ä¸ºäº†é¢„å…ˆçŸ¥é“ durationï¼ˆæœ‰äº›å®¹å™¨éœ€è¦ metadata loadedï¼‰
    await new Promise(res=>{ const f=()=>{audioEl.removeEventListener('loadedmetadata', f); res();}; audioEl.addEventListener('loadedmetadata', f); });
    const totalDur = isFinite(audioEl.duration)? audioEl.duration : 0;

    // åˆå§‹åŒ–å³°å€¼å®¹å™¨ï¼ˆæŒ‰åƒç´ åˆ—ï¼‰
    const width = Math.max(600, Math.floor(waveCanvas.getBoundingClientRect().width * dpr));
    peaks = new Array(width).fill(0).map(()=>[1,-1]);

    const startTime = performance.now();
    rec.start();
    await audioEl.play().catch(()=>{});

    // æ’­æ”¾è¿‡ç¨‹ä¸­å®šæ—¶æŠ½æ ·ï¼Œå¡«å…… peaks
    let rafId;
    await new Promise(resolve=>{
      const tick = ()=>{
        analyser.getFloatTimeDomainData(timeData);
        // å°†å½“å‰æ—¶é—´æ˜ å°„åˆ°åƒç´ åˆ—ï¼ˆå¦‚æœæ‹¿ä¸åˆ° durationï¼Œå°±æŒ‰å·²é‡‡æ ·è¿›åº¦å‡åŒ€æ¨è¿›ï¼‰
        const cur = audioEl.currentTime;
        const ratio = totalDur>0? (cur/totalDur) : Math.min(1, (performance.now()-startTime)/(1000*60*60*6)); // æœ€å¤š6å°æ—¶ä¼°è®¡
        const x = Math.min(width-1, Math.max(0, Math.floor(ratio*width)));
        let min=1, max=-1;
        for (let i=0;i<timeData.length;i++){ const v=timeData[i]; if(v<min)min=v; if(v>max)max=v; }
        if (min<peaks[x][0]) peaks[x][0]=min; if (max>peaks[x][1]) peaks[x][1]=max;
        draw();
        rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);
      const onEnded = ()=>{ cancelAnimationFrame(rafId); rec.stop(); audioEl.removeEventListener('ended', onEnded); resolve(); };
      audioEl.addEventListener('ended', onEnded);
      if (!isFinite(totalDur) || totalDur<=0){ setTimeout(onEnded, 10*60*1000); }
    });

    const out = new Blob(chunks, {type: mime||'application/octet-stream'});
    const arr = await out.arrayBuffer();
    URL.revokeObjectURL(url);
    showLoading(false);
    return await decodeArrayBufferWithFallback(arr, ctx);
  }

  async function decodeWithFallbackSmart(file, hintDuration){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state==='suspended'){ try{ await audioCtx.resume(); }catch(_){} }

    const longBySize = file.size >= LONG_FILE_BYTE_THRESHOLD;
    const longByDur = hintDuration && hintDuration >= LONG_FILE_DURATION_THRESHOLD;

    // å…ˆå°è¯•ç›´æ¥è§£ç ï¼ˆå°æ–‡ä»¶/çŸ­æ—¶é•¿ï¼‰
    if (!longBySize && !longByDur){
      try{ const arr = await file.arrayBuffer(); return await decodeArrayBufferWithFallback(arr, audioCtx); }
      catch(e){ /* å¤±è´¥å†èµ°è½¬ç  */ }
    }
    // é•¿éŸ³é¢‘æˆ–è§£ç å¤±è´¥ â†’ å®æ—¶è½¬ç å¹¶è¾¹å½•è¾¹æ„å»ºæ³¢å½¢
    return await transcodeViaMediaRecorderAndBuildPeaks(file, audioCtx);
  }

  async function loadFile(file){
    stop();
    try{
      showLoading(false);
      // å…ˆæ‹¿åˆ°å¤§æ¦‚æ—¶é•¿ï¼ˆå¦‚æœå®¹å™¨èƒ½è¯»ï¼‰
      let hintDuration = 0;
      try{
        hintDuration = await new Promise(res=>{
          const a=new Audio(); a.preload='metadata'; a.src=URL.createObjectURL(file);
          a.onloadedmetadata = ()=>{ res(isFinite(a.duration)? a.duration:0); URL.revokeObjectURL(a.src); };
          a.onerror = ()=>{ res(0); try{URL.revokeObjectURL(a.src);}catch{} };
        });
      }catch{}

      buffer = await decodeWithFallbackSmart(file, hintDuration);

      fileNameEl.textContent = file.name || 'æœªå‘½åéŸ³é¢‘';
      srEl.textContent = buffer.sampleRate + ' Hz';
      chEl.textContent = buffer.numberOfChannels;
      durEl.textContent = fmt(buffer.duration);

      if (!peaks.length) buildPeaks(); // è‹¥ä¸æ˜¯è¾¹å½•ç”Ÿæˆï¼Œå°±å¸¸è§„æ„å»º

      selection = {active:false,start:0,end:0};
      updateSelInfo();
      enableUI(true);
      resize();
    }catch(e){
      console.error(e);
      showLoading(false);
      alert((e && e.message) ? e.message : 'åŠ è½½å¤±è´¥ï¼šè¯¥éŸ³é¢‘åœ¨æ­¤è®¾å¤‡ä¸Šè§£ç å—é™ã€‚å¯å°è¯•å…ˆè½¬ä¸º WAV å†å¯¼å…¥ã€‚');
      enableUI(false);
    }
  }

  function buildPeaks(){
    if (!buffer){ peaks=[]; return; }
    const width = waveCanvas.width; // device px
    const samplesPerBucket = Math.max(1, Math.floor(buffer.length / width));
    const ch0 = buffer.getChannelData(0);
    const ch1 = buffer.numberOfChannels>1 ? buffer.getChannelData(1) : null;
    peaks = new Array(width);
    for (let i=0;i<width;i++){
      const start = i*samplesPerBucket;
      const end = Math.min((i+1)*samplesPerBucket, ch0.length);
      let min=1, max=-1;
      for (let j=start;j<end;j++){
        const vL = ch0[j];
        const vR = ch1 ? ch1[j] : vL;
        const v = (vL + vR) * 0.5; // average stereo
        if (v<min) min=v; if (v>max) max=v;
      }
      peaks[i] = [min, max];
    }
  }

  function secToX(sec){ const total = buffer?buffer.duration:1; const rectW = waveCanvas.width; return (sec/total) * rectW; }
  function xToSec(x){ const total = buffer?buffer.duration:1; const rectW = waveCanvas.width; return (x/rectW) * total; }

  function draw(){
    const ctx = waveCanvas.getContext('2d');
    ctx.clearRect(0,0,waveCanvas.width,waveCanvas.height);
    ctx.fillStyle = '#0b1020'; ctx.fillRect(0,0,waveCanvas.width,waveCanvas.height);

    if (!peaks.length){ drawGrid(); return; }

    const mid = waveCanvas.height/2;
    ctx.strokeStyle = 'rgba(148,163,184,.9)';
    ctx.beginPath();
    for (let x=0;x<peaks.length;x+=Math.max(1,Math.floor(2/zoom))){
      const p = peaks[x];
      const y1 = mid + p[0]*mid*0.95;
      const y2 = mid + p[1]*mid*0.95;
      ctx.moveTo(x+0.5, y1);
      ctx.lineTo(x+0.5, y2);
    }
    ctx.stroke();

    drawGrid();
    updateSelectionOverlay();
  }

  function drawGrid(){
    if (!buffer) return; // æ²¡æœ‰æ—¶é•¿å°±ä¸ç”»ç½‘æ ¼
    const g = gridCanvas.getContext('2d');
    g.clearRect(0,0,gridCanvas.width,gridCanvas.height);
    const dur = buffer.duration; const w = gridCanvas.width; const h = gridCanvas.height;
    g.fillStyle = 'rgba(255,255,255,.03)';
    for (let i=0;i<5;i++){ const y=(i/4)*h; g.fillRect(0,y,w,1); }
    const pxPerSec = w/dur; const major = Math.max(1, Math.round(100/pxPerSec));
    g.font = `${12*dpr}px ui-monospace,monospace`; g.textBaseline='top'; g.fillStyle='rgba(200,200,220,.8)';
    g.strokeStyle='rgba(255,255,255,.12)';
    for (let s=0; s<=dur; s+=major){ const x = Math.floor(s*pxPerSec)+0.5; g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke(); const label = fmt(s).replace(/^[^:]+:/,''); g.fillText(label, x+4, 4); }
  }

  function updateSelectionOverlay(){
    if (!buffer || !selection.active){ selEl.style.width='0px'; return; }
    const x1 = secToX(selection.start)/dpr; const x2 = secToX(selection.end)/dpr;
    selEl.style.left = Math.min(x1,x2)+ 'px'; selEl.style.width = Math.max(1, Math.abs(x2-x1)) + 'px';
  }

  function updateSelInfo(){
    selStartEl.textContent = selection.active? fmt(Math.min(selection.start, selection.end)) : 'â€”';
    selEndEl.textContent   = selection.active? fmt(Math.max(selection.start, selection.end)) : 'â€”';
    exportWavBtn.disabled = !selection.active || !buffer;
    exportMp3Btn.disabled = !selection.active || !buffer;
    resetSelBtn.disabled = !selection.active;
  }

  // Mouse/touch selection
  let dragging = false;
  function onDown(clientX){ if (!buffer) return; dragging=true; selection.active=true; const rect = waveCanvas.getBoundingClientRect(); const x=(clientX-rect.left)*dpr; selection.start = xToSec(x); selection.end=selection.start; updateSelInfo(); draw(); }
  function onMove(clientX){ if (!dragging||!buffer) return; const rect = waveCanvas.getBoundingClientRect(); const x=(clientX-rect.left)*dpr; selection.end=Math.min(buffer.duration, Math.max(0, xToSec(x))); updateSelInfo(); draw(); }
  function onUp(){ dragging=false; }
  waveCanvas.addEventListener('mousedown', e=> onDown(e.clientX));
  window.addEventListener('mousemove', e=> onMove(e.clientX));
  window.addEventListener('mouseup', onUp);
  waveCanvas.addEventListener('touchstart', e=>{ if(e.touches[0]) onDown(e.touches[0].clientX);});
  window.addEventListener('touchmove', e=>{ if(e.touches[0]) onMove(e.touches[0].clientX);});
  window.addEventListener('touchend', onUp);

  // Playback
  let playStartTime = 0; let playStartOffset = 0;
  function startNode(offsetSec, durationSec){
    stop();
    if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    srcNode = audioCtx.createBufferSource(); srcNode.buffer = buffer; srcNode.connect(audioCtx.destination); srcNode.loop = loop && selection.active;
    if (srcNode.loop){ const a=Math.min(selection.start, selection.end); const b=Math.max(selection.start, selection.end); srcNode.loopStart=a; srcNode.loopEnd=b; srcNode.start(0,a); playStartOffset=a; }
    else { srcNode.start(0, offsetSec||0, durationSec||undefined); playStartOffset = offsetSec||0; }
    playStartTime = audioCtx.currentTime; playing = true; playBtn.textContent='â¸ï¸ æš‚åœ'; rafPlayhead();
    srcNode.onended=()=>{ if(!srcNode) return; if(!srcNode.loop){ playing=false; playBtn.textContent='â–¶ï¸ æ’­æ”¾/æš‚åœ'; updatePlayhead(0);} };
  }
  function play(){ if(!buffer) return; if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); if(playing){ pause(); return; } if (selection.active){ const a=Math.min(selection.start, selection.end); const b=Math.max(selection.start, selection.end); startNode(a, b-a);} else { startNode(0);} }
  function pause(){ if(!playing) return; const elapsed = audioCtx.currentTime - playStartTime; playStartOffset += elapsed; stop(true); playing=false; playBtn.textContent='â–¶ï¸ æ’­æ”¾/æš‚åœ'; }
  function stop(keepOffset=false){ if(srcNode){ try{srcNode.stop();}catch(_){} try{srcNode.disconnect();}catch(_){} } srcNode=null; if(!keepOffset){ playStartOffset=0;} playBtn.textContent='â–¶ï¸ æ’­æ”¾/æš‚åœ'; playing=false; updatePlayhead(0); }
  function updatePlayhead(forcedX){ if(!buffer){ playheadEl.style.width='0px'; return; } let curSec; if(playing){ const elapsed=audioCtx.currentTime - playStartTime; curSec=(playStartOffset+elapsed)%buffer.duration; } else { curSec= selection.active? Math.min(selection.end, buffer.duration):0; } const x = forcedX || (secToX(curSec)/dpr); playheadEl.style.width = Math.max(0, Math.min(x, waveCanvas.clientWidth)) + 'px'; }
  function rafPlayhead(){ if(!playing) return; updatePlayhead(); requestAnimationFrame(rafPlayhead); }

  // ===== å¯¼å‡ºï¼šWAV & MP3 =====
  function getSelectionFloat32(){
    if (!buffer || !selection.active) return null;
    const a = Math.max(0, Math.min(selection.start, selection.end));
    const b = Math.max(0, Math.min(buffer.duration, Math.max(selection.start, selection.end)));
    const sr = buffer.sampleRate; const startFrame = Math.floor(a*sr); const endFrame = Math.floor(b*sr); const frameCount = Math.max(0, endFrame - startFrame); const ch = buffer.numberOfChannels;
    const channels=[]; for (let c=0;c<ch;c++){ const src = buffer.getChannelData(c); const slice = new Float32Array(frameCount); slice.set(src.subarray(startFrame, endFrame)); channels.push(slice);}    
    return {channels, sampleRate: sr};
  }

  function exportSelectionWav(){
    const data = getSelectionFloat32(); if(!data) return;
    const wav = encodeWAVFromFloat32(data.channels, data.sampleRate);
    const blob = new Blob([wav], {type:'audio/wav'});
    triggerDownload(blob, '.wav');
  }

  async function exportSelectionMp3(){
    const data = getSelectionFloat32(); if(!data) return;
    // åŠ¨æ€åŠ è½½ lamejsï¼ˆä»…åœ¨ç¬¬ä¸€æ¬¡å¯¼å‡º MP3 æ—¶åŠ è½½ï¼‰
    if (!window.lamejs){
      await new Promise((res, rej)=>{
        const s=document.createElement('script');
        s.src='https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js';
        s.onload=res; s.onerror=()=>rej(new Error('æ— æ³•åŠ è½½ MP3 ç¼–ç åº“ï¼ˆlamejsï¼‰ã€‚'));
        document.head.appendChild(s);
      });
    }
    const {channels, sampleRate} = data;
    // lamejs åªèƒ½ç¼–ç  1 æˆ– 2 é€šé“ï¼Œè‹¥>2ï¼Œé™åˆ°ç«‹ä½“å£°
    const ch = Math.min(2, channels.length);
    const left = channels[0];
    const right = ch>1? channels[1] : channels[0];

    // å°† Float32 [-1,1] è½¬ Int16
    function f32ToS16PCM(f){ const out = new Int16Array(f.length); for (let i=0;i<f.length;i++){ let s = Math.max(-1, Math.min(1, f[i])); out[i] = s<0 ? s*0x8000 : s*0x7FFF; } return out; }
    const leftS16 = f32ToS16PCM(left);
    const rightS16 = f32ToS16PCM(right);

    const kbps = 128; // ç ç‡
    const encoder = new lamejs.Mp3Encoder(ch, sampleRate, kbps);
    const blockSize = 1152; // MP3 å¸§å¤§å°
    const mp3Data = [];
    for (let i=0;i<leftS16.length; i+=blockSize){
      const l = leftS16.subarray(i, i+blockSize);
      const r = rightS16.subarray(i, i+blockSize);
      const chunk = ch===2? encoder.encodeBuffer(l, r) : encoder.encodeBuffer(l);
      if (chunk.length) mp3Data.push(chunk);
    }
    const end = encoder.flush(); if (end.length) mp3Data.push(end);
    const blob = new Blob(mp3Data, {type:'audio/mpeg'});
    triggerDownload(blob, '.mp3');
  }

  function triggerDownload(blob, ext){
    const url = URL.createObjectURL(blob);
    const base = (document.getElementById('fileName').textContent||'audio').replace(/\.[^/.]+$/,'');
    const a = Math.max(0, Math.min(selection.start, selection.end));
    const b = Math.max(0, Math.min(buffer.duration, Math.max(selection.start, selection.end)));
    const name = `${base}_${fmt(a).replace(/[:.]/g,'')}-${fmt(b).replace(/[:.]/g,'')}${ext}`;
    const aEl = document.createElement('a'); aEl.href=url; aEl.download=name; aEl.click(); setTimeout(()=>URL.revokeObjectURL(url),10000);
  }

  function encodeWAVFromFloat32(channels, sampleRate){
    const numChannels = channels.length; const numFrames = channels[0].length; const bytesPerSample = 2; const blockAlign = numChannels * bytesPerSample; const byteRate = sampleRate * blockAlign; const dataSize = numFrames * blockAlign; const buf = new ArrayBuffer(44 + dataSize); const view = new DataView(buf);
    function wstr(off,str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }
    wstr(0,'RIFF'); view.setUint32(4, 36 + dataSize, true); wstr(8,'WAVE'); wstr(12,'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true); view.setUint16(34, 16, true); wstr(36,'data'); view.setUint32(40, dataSize, true);
    let offset=44; for (let i=0;i<numFrames;i++){ for (let ch=0; ch<numChannels; ch++){ let s = channels[ch][i]; s = Math.max(-1, Math.min(1, s)); const v = s < 0 ? s * 0x8000 : s * 0x7FFF; view.setInt16(offset, v, true); offset+=2; } }
    return view;
  }

  // Events
  fileInput.addEventListener('change', async e=>{ const f = e.target.files && e.target.files[0]; if (!f) return; await loadFile(f); });
  playBtn.addEventListener('click', play);
  stopBtn.addEventListener('click', ()=> stop());
  exportWavBtn.addEventListener('click', exportSelectionWav);
  exportMp3Btn.addEventListener('click', exportSelectionMp3);
  loopBtn.addEventListener('click', ()=>{ loop = !loop; loopBtn.textContent = loop? 'ğŸ” å¾ªç¯å¼€' : 'ğŸ” å¾ªç¯å…³'; if (srcNode) { srcNode.loop = loop && selection.active; } });
  fitBtn.addEventListener('click', ()=>{ zoom = 1; zoomRange.value=1; draw(); });
  zoomInBtn.addEventListener('click', ()=>{ zoom = Math.min(10, zoom+1); zoomRange.value=zoom; draw(); });
  zoomOutBtn.addEventListener('click', ()=>{ zoom = Math.max(1, zoom-1); zoomRange.value=zoom; draw(); });
  resetSelBtn.addEventListener('click', ()=>{ selection={active:false,start:0,end:0}; updateSelInfo(); draw(); });
  zoomRange.addEventListener('input', e=>{ zoom = +e.target.value; draw(); });
  window.addEventListener('keydown', e=>{ if (e.code==='Space'){ e.preventDefault(); play(); } if ((e.ctrlKey||e.metaKey) && (e.key==='e'||e.key==='E')){ e.preventDefault(); exportSelectionWav(); } });

  // Init
  enableUI(false); resize();
})();
</script>
</body>
</html>

<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>本地音频剪裁（iPad MP3 兼容整合版）</title>
  <style>
    :root{--bg:#0f172a;--panel:#0b1220;--muted:#94a3b8;--accent:#22c55e;--accent2:#60a5fa;--text:#e5e7eb;--danger:#ef4444}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1020,#0a0f1f);color:var(--text);font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Noto Sans CJK SC","Microsoft Yahei",sans-serif}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    .card{background:rgba(255,255,255,0.04);backdrop-filter: blur(6px);border:1px solid rgba(255,255,255,.08);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .head{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.08)}
    .head h1{font-size:18px;margin:0;font-weight:700}
    .controls{display:flex;flex-wrap:wrap;gap:8px}
    input[type=file]{display:none}
    .btn{appearance:none;border:none;border-radius:12px;padding:10px 14px;color:#fff;background:#1f2937;cursor:pointer;transition:.2s ease;display:inline-flex;gap:8px;align-items:center}
    .btn:hover{filter:brightness(1.15)}
    .btn.primary{background:linear-gradient(180deg,var(--accent),#179d48)}
    .btn.blue{background:linear-gradient(180deg,var(--accent2),#2563eb)}
    .btn.danger{background:linear-gradient(180deg,var(--danger),#b91c1c)}
    .btn.ghost{background:transparent;outline:1px solid rgba(255,255,255,.15)}
    .btn:disabled{opacity:.55;cursor:not-allowed}
    .body{padding:16px}
    .canvas-wrap{position:relative;border-radius:14px;overflow:hidden;border:1px solid rgba(255,255,255,.08);background:#0a0f1c}
    canvas{display:block;width:100%;height:180px}
    .timeline{position:absolute;inset:0;pointer-events:none}
    .info{display:grid;grid-template-columns: repeat(6,minmax(0,1fr));gap:12px;margin-top:12px}
    .stat{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px}
    .stat small{display:block;color:var(--muted);font-size:12px}
    .stat b{font-size:16px}
    .footer{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between;margin-top:14px}
    .range{display:flex;gap:8px;align-items:center}
    input[type=range]{width:200px}
    .kbd{font:12px/1.2 ui-monospace,Menlo,monospace;color:#cbd5e1;background:#0b1220;border:1px solid rgba(255,255,255,.1);padding:3px 6px;border-radius:8px}
    .progress{position:absolute;left:0;top:0;height:100%;width:0;background:rgba(56,189,248,.08);pointer-events:none}
    .sel{position:absolute;top:0;height:100%;left:0;width:0;background:rgba(34,197,94,.18);outline:1px dashed rgba(34,197,94,.9);pointer-events:none}
    .notice{color:#a1a1aa;font-size:14px;margin-top:10px}
    .loading{display:none;gap:8px;align-items:center}
    .loading.on{display:inline-flex}
    .dot{width:8px;height:8px;border-radius:50%;background:#60a5fa;animation: b 1s infinite}
    .dot:nth-child(2){animation-delay:.15s}.dot:nth-child(3){animation-delay:.3s}
    @keyframes b{0%{transform:translateY(0)}50%{transform:translateY(-4px)}100%{transform:translateY(0)}}
  </style>
</head>
<body>
  <div class="wrap card">
    <div class="head">
      <h1>本地音频剪裁 <span style="opacity:.6">｜iPad MP3 兼容</span></h1>
      <div class="controls">
        <label class="btn blue" for="fileInput">📂 载入音频</label>
        <input id="fileInput" type="file" accept="audio/*,.mp3,audio/mpeg,.m4a" />
        <button id="playBtn" class="btn" disabled>▶️ 播放/暂停</button>
        <button id="stopBtn" class="btn ghost" disabled>⏹️ 停止</button>
        <button id="loopBtn" class="btn ghost" disabled>🔁 循环关</button>
        <button id="fitBtn" class="btn ghost" disabled>🧭 适配波形</button>
        <button id="zoomInBtn" class="btn ghost" disabled>➕ 放大</button>
        <button id="zoomOutBtn" class="btn ghost" disabled>➖ 缩小</button>
        <button id="resetSelBtn" class="btn ghost" disabled>🧹 清除选区</button>
        <button id="exportBtn" class="btn primary" disabled>⬇️ 导出选段 (WAV)</button>
      </div>
    </div>
    <div class="body">
      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="wave"></canvas>
        <div class="progress" id="playhead"></div>
        <div class="sel" id="selection"></div>
        <canvas class="timeline" id="grid"></canvas>
      </div>
      <div class="info">
        <div class="stat"><small>文件名</small><b id="fileName">—</b></div>
        <div class="stat"><small>采样率</small><b id="sampleRate">—</b></div>
        <div class="stat"><small>声道数</small><b id="channels">—</b></div>
        <div class="stat"><small>时长</small><b id="duration">—</b></div>
        <div class="stat"><small>选择开始</small><b id="selStart">—</b></div>
        <div class="stat"><small>选择结束</small><b id="selEnd">—</b></div>
      </div>
      <div class="footer">
        <div>
          <span class="hint">提示：拖动波形框选；<span class="kbd">Space</span> 播放/暂停，<span class="kbd">Ctrl/Cmd+E</span> 导出。</span>
          <span id="loading" class="loading" style="margin-left:10px"><span class="dot"></span><span class="dot"></span><span class="dot"></span><span> 正在转码以兼容 iPad…</span></span>
          <div class="notice">若 MP3 在 iPad 上无法直接解码，页面会自动通过 <code>MediaRecorder</code> 静音转码后再显示波形（会耗时≈音频时长）。</div>
        </div>
        <div class="range">
          <span>缩放：</span>
          <input id="zoomRange" type="range" min="1" max="10" step="1" value="1" disabled />
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const waveCanvas = document.getElementById('wave');
  const gridCanvas = document.getElementById('grid');
  const wrap = document.getElementById('canvasWrap');
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const loopBtn = document.getElementById('loopBtn');
  const exportBtn = document.getElementById('exportBtn');
  const fitBtn = document.getElementById('fitBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetSelBtn = document.getElementById('resetSelBtn');
  const zoomRange = document.getElementById('zoomRange');
  const playheadEl = document.getElementById('playhead');
  const selEl = document.getElementById('selection');
  const loading = document.getElementById('loading');

  const fileNameEl = document.getElementById('fileName');
  const srEl = document.getElementById('sampleRate');
  const chEl = document.getElementById('channels');
  const durEl = document.getElementById('duration');
  const selStartEl = document.getElementById('selStart');
  const selEndEl = document.getElementById('selEnd');

  let audioCtx; // AudioContext
  let buffer;   // AudioBuffer
  let srcNode;  // BufferSourceNode
  let playing = false;
  let loop = false;

  let zoom = 1;      // 1..10
  let peaks = [];    // downsampled peaks

  let selection = {active:false, start:0, end:0}; // seconds

  const dpr = Math.max(1, window.devicePixelRatio || 1);

  function fmt(t){
    if (!isFinite(t)) return '—';
    const sign = t < 0 ? '-' : '';
    t = Math.max(0, t);
    const m = Math.floor(t/60);
    const s = Math.floor(t%60);
    const ms = Math.floor((t*1000)%1000);
    return `${sign}${m}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
  }

  function enableUI(enabled){
    [playBtn, stopBtn, loopBtn, exportBtn, fitBtn, zoomInBtn, zoomOutBtn, resetSelBtn, zoomRange].forEach(b=>b.disabled=!enabled);
  }

  function showLoading(on){ loading.classList.toggle('on', !!on); }

  function resize(){
    const rect = wrap.getBoundingClientRect();
    [waveCanvas, gridCanvas].forEach(cv=>{
      cv.width = Math.floor(rect.width * dpr);
      cv.height = Math.floor(180 * dpr);
      cv.style.width = rect.width + 'px';
      cv.style.height = '180px';
    });
    draw();
  }
  window.addEventListener('resize', resize);

  // ===== iOS/Safari MP3 兜底：失败则用 <audio> + MediaRecorder 转码再解码 =====
  async function decodeArrayBufferWithFallback(arrBuf, ctx){
    try{ return await ctx.decodeAudioData(arrBuf.slice(0)); }
    catch(e1){
      return await new Promise((resolve, reject)=>{
        try{ ctx.decodeAudioData(arrBuf.slice(0), resolve, reject); }
        catch(e2){ reject(e2); }
      });
    }
  }

  async function transcodeViaMediaRecorder(file, ctx){
    if (!('MediaRecorder' in window)) throw new Error('此浏览器不支持 MediaRecorder 兜底。');
    const audioEl = new Audio();
    audioEl.preload='auto';
    audioEl.muted = true; // 静音播放以便录制
    const url = URL.createObjectURL(file);
    audioEl.src = url;

    const dest = ctx.createMediaStreamDestination();
    const src = ctx.createMediaElementSource(audioEl);
    src.connect(dest);
    src.connect(ctx.destination);

    let mime = '';
    try{
      if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/mp4')) mime='audio/mp4';
      else if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm')) mime='audio/webm';
    }catch(_){ mime=''; }

    const chunks=[];
    const rec = mime? new MediaRecorder(dest.stream,{mimeType:mime}) : new MediaRecorder(dest.stream);
    rec.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };

    if (ctx.state==='suspended'){ try{ await ctx.resume(); }catch(_){} }
    await audioEl.play().catch(()=>{});
    rec.start();

    await new Promise(res=>{
      const end = ()=>{ try{rec.stop();}catch(_){ } audioEl.removeEventListener('ended', end); res(); };
      audioEl.addEventListener('ended', end);
      if (!isFinite(audioEl.duration) || audioEl.duration<=0){ setTimeout(end, 10*60*1000); }
    });

    const out = new Blob(chunks, {type: mime||'application/octet-stream'});
    const arr = await out.arrayBuffer();
    URL.revokeObjectURL(url);
    return await decodeArrayBufferWithFallback(arr, ctx);
  }

  async function decodeWithFallback(file){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state==='suspended'){ try{ await audioCtx.resume(); }catch(_){} }
    try{
      const arr = await file.arrayBuffer();
      return await decodeArrayBufferWithFallback(arr, audioCtx);
    }catch(e){
      showLoading(true);
      try{ return await transcodeViaMediaRecorder(file, audioCtx); }
      finally{ showLoading(false); }
    }
  }

  async function loadFile(file){
    stop();
    try{
      buffer = await decodeWithFallback(file);
      fileNameEl.textContent = file.name || '未命名音频';
      srEl.textContent = buffer.sampleRate + ' Hz';
      chEl.textContent = buffer.numberOfChannels;
      durEl.textContent = fmt(buffer.duration);
      buildPeaks();
      selection = {active:false,start:0,end:0};
      updateSelInfo();
      enableUI(true);
      resize();
    }catch(e){
      console.error(e);
      alert((e && e.message) ? e.message : '加载失败：该音频在此设备上解码受限。可尝试用第三方App先转为 WAV 再导入。');
      enableUI(false);
    }
  }

  function buildPeaks(){
    if (!buffer){ peaks=[]; return; }
    const width = waveCanvas.width; // device px
    const samplesPerBucket = Math.max(1, Math.floor(buffer.length / width));
    const ch0 = buffer.getChannelData(0);
    const ch1 = buffer.numberOfChannels>1 ? buffer.getChannelData(1) : null;
    peaks = new Array(width);
    for (let i=0;i<width;i++){
      const start = i*samplesPerBucket;
      const end = Math.min((i+1)*samplesPerBucket, ch0.length);
      let min=1, max=-1;
      for (let j=start;j<end;j++){
        const vL = ch0[j];
        const vR = ch1 ? ch1[j] : vL;
        const v = (vL + vR) * 0.5;
        if (v<min) min=v; if (v>max) max=v;
      }
      peaks[i] = [min, max];
    }
  }

  function secToX(sec){ const total = buffer?buffer.duration:1; const rectW = waveCanvas.width; return (sec/total) * rectW; }
  function xToSec(x){ const total = buffer?buffer.duration:1; const rectW = waveCanvas.width; return (x/rectW) * total; }

  function draw(){
    const ctx = waveCanvas.getContext('2d');
    ctx.clearRect(0,0,waveCanvas.width,waveCanvas.height);
    ctx.fillStyle = '#0b1020'; ctx.fillRect(0,0,waveCanvas.width,waveCanvas.height);

    if (!buffer || !peaks.length){ drawGrid(); return; }

    const mid = waveCanvas.height/2;
    ctx.strokeStyle = 'rgba(148,163,184,.9)';
    ctx.beginPath();
    for (let x=0;x<peaks.length;x+=Math.max(1,Math.floor(2/zoom))){
      const p = peaks[x];
      const y1 = mid + p[0]*mid*0.95;
      const y2 = mid + p[1]*mid*0.95;
      ctx.moveTo(x+0.5, y1);
      ctx.lineTo(x+0.5, y2);
    }
    ctx.stroke();

    drawGrid();
    updateSelectionOverlay();
  }

  function drawGrid(){
    const g = gridCanvas.getContext('2d');
    g.clearRect(0,0,gridCanvas.width,gridCanvas.height);
    if (!buffer) return;
    const dur = buffer.duration; const w = gridCanvas.width; const h = gridCanvas.height;
    g.fillStyle = 'rgba(255,255,255,.03)';
    for (let i=0;i<5;i++){ const y=(i/4)*h; g.fillRect(0,y,w,1); }
    const pxPerSec = w/dur; const major = Math.max(1, Math.round(100/pxPerSec));
    g.font = `${12*dpr}px ui-monospace,monospace`; g.textBaseline='top'; g.fillStyle='rgba(200,200,220,.8)';
    g.strokeStyle='rgba(255,255,255,.12)';
    for (let s=0; s<=dur; s+=major){ const x = Math.floor(s*pxPerSec)+0.5; g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke(); const label = fmt(s).replace(/^[^:]+:/,''); g.fillText(label, x+4, 4); }
  }

  function updateSelectionOverlay(){
    if (!buffer || !selection.active){ selEl.style.width='0px'; return; }
    const x1 = secToX(selection.start)/dpr; const x2 = secToX(selection.end)/dpr;
    selEl.style.left = Math.min(x1,x2)+ 'px'; selEl.style.width = Math.max(1, Math.abs(x2-x1)) + 'px';
  }

  function updateSelInfo(){
    selStartEl.textContent = selection.active? fmt(Math.min(selection.start, selection.end)) : '—';
    selEndEl.textContent   = selection.active? fmt(Math.max(selection.start, selection.end)) : '—';
    exportBtn.disabled = !selection.active || !buffer;
    resetSelBtn.disabled = !selection.active;
  }

  // Mouse/touch selection
  let dragging = false;
  function onDown(clientX){ if (!buffer) return; dragging=true; selection.active=true; const rect = waveCanvas.getBoundingClientRect(); const x=(clientX-rect.left)*dpr; selection.start = xToSec(x); selection.end=selection.start; updateSelInfo(); draw(); }
  function onMove(clientX){ if (!dragging||!buffer) return; const rect = waveCanvas.getBoundingClientRect(); const x=(clientX-rect.left)*dpr; selection.end=Math.min(buffer.duration, Math.max(0, xToSec(x))); updateSelInfo(); draw(); }
  function onUp(){ dragging=false; }
  waveCanvas.addEventListener('mousedown', e=> onDown(e.clientX));
  window.addEventListener('mousemove', e=> onMove(e.clientX));
  window.addEventListener('mouseup', onUp);
  waveCanvas.addEventListener('touchstart', e=>{ if(e.touches[0]) onDown(e.touches[0].clientX);});
  window.addEventListener('touchmove', e=>{ if(e.touches[0]) onMove(e.touches[0].clientX);});
  window.addEventListener('touchend', onUp);

  // Playback
  let playStartTime = 0; let playStartOffset = 0;
  function startNode(offsetSec, durationSec){
    stop();
    srcNode = audioCtx.createBufferSource(); srcNode.buffer = buffer; srcNode.connect(audioCtx.destination); srcNode.loop = loop && selection.active;
    if (srcNode.loop){ const a=Math.min(selection.start, selection.end); const b=Math.max(selection.start, selection.end); srcNode.loopStart=a; srcNode.loopEnd=b; srcNode.start(0,a); playStartOffset=a; }
    else { srcNode.start(0, offsetSec||0, durationSec||undefined); playStartOffset = offsetSec||0; }
    playStartTime = audioCtx.currentTime; playing = true; playBtn.textContent='⏸️ 暂停'; rafPlayhead();
    srcNode.onended=()=>{ if(!srcNode) return; if(!srcNode.loop){ playing=false; playBtn.textContent='▶️ 播放/暂停'; updatePlayhead(0);} };
  }
  function play(){ if(!buffer) return; if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); if(playing){ pause(); return; } if (selection.active){ const a=Math.min(selection.start, selection.end); const b=Math.max(selection.start, selection.end); startNode(a, b-a);} else { startNode(0);} }
  function pause(){ if(!playing) return; const elapsed = audioCtx.currentTime - playStartTime; playStartOffset += elapsed; stop(true); playing=false; playBtn.textContent='▶️ 播放/暂停'; }
  function stop(keepOffset=false){ if(srcNode){ try{srcNode.stop();}catch(_){} try{srcNode.disconnect();}catch(_){} } srcNode=null; if(!keepOffset){ playStartOffset=0;} playBtn.textContent='▶️ 播放/暂停'; playing=false; updatePlayhead(0); }
  function updatePlayhead(forcedX){ if(!buffer){ playheadEl.style.width='0px'; return; } let curSec; if(playing){ const elapsed=audioCtx.currentTime - playStartTime; curSec=(playStartOffset+elapsed)%buffer.duration; } else { curSec= selection.active? Math.min(selection.end, buffer.duration):0; } const x = forcedX || (secToX(curSec)/dpr); playheadEl.style.width = Math.max(0, Math.min(x, waveCanvas.clientWidth)) + 'px'; }
  function rafPlayhead(){ if(!playing) return; updatePlayhead(); requestAnimationFrame(rafPlayhead); }

  // Export WAV
  function exportSelection(){
    if (!buffer || !selection.active) return;
    const a = Math.max(0, Math.min(selection.start, selection.end));
    const b = Math.max(0, Math.min(buffer.duration, Math.max(selection.start, selection.end)));
    const sr = buffer.sampleRate; const startFrame = Math.floor(a*sr); const endFrame = Math.floor(b*sr); const frameCount = Math.max(0, endFrame - startFrame); const ch = buffer.numberOfChannels;
    const channels=[]; for (let c=0;c<ch;c++){ const src = buffer.getChannelData(c); const slice = new Float32Array(frameCount); slice.set(src.subarray(startFrame, endFrame)); channels.push(slice);}    
    const wav = encodeWAVFromFloat32(channels, sr);
    const blob = new Blob([wav], {type:'audio/wav'});
    const url = URL.createObjectURL(blob);
    const base = (document.getElementById('fileName').textContent||'audio').replace(/\.[^/.]+$/,'');
    const aEl = document.createElement('a');
    aEl.download = `${base}_${fmt(a).replace(/[:.]/g,'')}-${fmt(b).replace(/[:.]/g,'')}.wav`;
    aEl.href = url; aEl.click();
    setTimeout(()=> URL.revokeObjectURL(url), 10000);
  }

  function encodeWAVFromFloat32(channels, sampleRate){
    const numChannels = channels.length; const numFrames = channels[0].length; const bytesPerSample = 2; const blockAlign = numChannels * bytesPerSample; const byteRate = sampleRate * blockAlign; const dataSize = numFrames * blockAlign; const buffer = new ArrayBuffer(44 + dataSize); const view = new DataView(buffer);
    function writeStr(off, str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }
    writeStr(0,'RIFF'); view.setUint32(4, 36 + dataSize, true); writeStr(8,'WAVE');
    writeStr(12,'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true); view.setUint16(34, 16, true);
    writeStr(36,'data'); view.setUint32(40, dataSize, true);
    let offset = 44; for (let i=0;i<numFrames;i++){ for (let ch=0; ch<numChannels; ch++){ let s = channels[ch][i]; s = Math.max(-1, Math.min(1, s)); const v = s < 0 ? s * 0x8000 : s * 0x7FFF; view.setInt16(offset, v, true); offset+=2; } }
    return view;
  }

  // Events
  fileInput.addEventListener('change', async e=>{ const f = e.target.files && e.target.files[0]; if (!f) return; await loadFile(f); });
  playBtn.addEventListener('click', play);
  stopBtn.addEventListener('click', ()=> stop());
  exportBtn.addEventListener('click', exportSelection);
  loopBtn.addEventListener('click', ()=>{ loop = !loop; loopBtn.textContent = loop? '🔁 循环开' : '🔁 循环关'; if (srcNode) { srcNode.loop = loop && selection.active; } });
  fitBtn.addEventListener('click', ()=>{ zoom = 1; zoomRange.value=1; draw(); });
  zoomInBtn.addEventListener('click', ()=>{ zoom = Math.min(10, zoom+1); zoomRange.value=zoom; draw(); });
  zoomOutBtn.addEventListener('click', ()=>{ zoom = Math.max(1, zoom-1); zoomRange.value=zoom; draw(); });
  resetSelBtn.addEventListener('click', ()=>{ selection={active:false,start:0,end:0}; updateSelInfo(); draw(); });
  zoomRange.addEventListener('input', e=>{ zoom = +e.target.value; draw(); });
  window.addEventListener('keydown', e=>{ if (e.code==='Space'){ e.preventDefault(); play(); } if ((e.ctrlKey||e.metaKey) && (e.key==='e'||e.key==='E')){ e.preventDefault(); exportSelection(); } });

  enableUI(false); resize();
})();
</script>
</body>
</html>

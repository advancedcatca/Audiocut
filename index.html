<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>本地音频剪裁｜分段加载 + 热力条 + 可调阈值</title>
  <style>
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC",sans-serif;background:#0b1020;color:#e5e7eb}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    .card{background:rgba(255,255,255,0.05);border-radius:16px;padding:16px}
    .head{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .controls{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px;align-items:center}
    .btn{padding:8px 12px;border:none;border-radius:8px;cursor:pointer;color:#fff;background:#374151}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    input[type=number]{width:90px;padding:6px;border-radius:6px;border:1px solid #334155;background:#0b1020;color:#e5e7eb}
    canvas{display:block;width:100%;height:180px;background:#111827;border-radius:8px;margin-top:12px}
    #heatmap{height:28px;margin-top:10px;background:#0f172a;border-radius:6px}
    .sel{position:absolute;top:0;height:100%;background:rgba(34,197,94,.2);outline:1px dashed #22c55e;pointer-events:none}
  </style>
</head>
<body>
  <div class="wrap card">
    <div class="head">
      <h1>本地音频剪裁｜分段加载</h1>
      <input id="fileInput" type="file" accept="audio/*,.mp3,.m4a" />
    </div>
    <!-- 全局热力条（点击跳转） -->
    <canvas id="heatmap"></canvas>

    <div class="controls">
      <button id="playBtn" class="btn" disabled>▶️ 播放/暂停</button>
      <button id="exportWavBtn" class="btn" disabled>⬇️ 导出 WAV</button>
      <button id="exportMp3Btn" class="btn" disabled>⬇️ 导出 MP3</button>
      <label style="display:inline-flex;align-items:center;gap:6px">窗口(s)
        <input id="winSec" type="number" min="10" max="1800" step="10" value="600">
      </label>
      <label style="display:inline-flex;align-items:center;gap:6px">阈值
        <input id="thInput" type="number" min="0" max="0.2" step="0.005" value="0.08">
      </label>
      <label style="display:inline-flex;align-items:center;gap:6px">最短(s)
        <input id="minDurInput" type="number" min="5" max="60" step="5" value="15">
      </label>
      <button id="prevBtn" class="btn" disabled>⏮️ 上一窗口</button>
      <button id="nextBtn" class="btn" disabled>⏭️ 下一窗口</button>
      <button id="prevTalkBtn" class="btn" disabled>🔉 上一段对话</button>
      <button id="nextTalkBtn" class="btn" disabled>🔊 下一段对话</button>
    </div>

    <div style="position:relative">
      <canvas id="wave"></canvas>
      <div id="selection" class="sel"></div>
    </div>

    <div id="info" style="margin-top:8px;color:#cbd5e1"></div>
  </div>
<script>
const fileInput=document.getElementById('fileInput');
const waveCanvas=document.getElementById('wave');
const heatmapCanvas=document.getElementById('heatmap');
const ctx=waveCanvas.getContext('2d');
const playBtn=document.getElementById('playBtn');
const exportWavBtn=document.getElementById('exportWavBtn');
const exportMp3Btn=document.getElementById('exportMp3Btn');
const prevBtn=document.getElementById('prevBtn');
const nextBtn=document.getElementById('nextBtn');
const prevTalkBtn=document.getElementById('prevTalkBtn');
const nextTalkBtn=document.getElementById('nextTalkBtn');
const winSecInput=document.getElementById('winSec');
const thInput=document.getElementById('thInput');
const minDurInput=document.getElementById('minDurInput');
const selEl=document.getElementById('selection');
const info=document.getElementById('info');

let audioCtx, buffer, srcNode, peaks=[];
let selection={active:false,start:0,end:0};
let viewOffsetSec=0; // 当前窗口起点（秒）
let winSec=600;      // 窗口长度（秒）
let loudness=[], loudKnown=[]; // 5s/格

function fmt(t){const m=Math.floor(t/60), s=Math.floor(t%60);return `${m}:${String(s).padStart(2,'0')}`}
function resize(){
  waveCanvas.width=waveCanvas.clientWidth*devicePixelRatio;
  waveCanvas.height=180*devicePixelRatio;
  heatmapCanvas.width=heatmapCanvas.clientWidth*devicePixelRatio;
  heatmapCanvas.height=28*devicePixelRatio;
  drawHeatmap(); draw();
}
window.addEventListener('resize',resize);resize();

function draw(){
  ctx.clearRect(0,0,waveCanvas.width,waveCanvas.height);
  if(!peaks.length)return;
  const mid=waveCanvas.height/2; ctx.strokeStyle='#60a5fa'; ctx.beginPath();
  for(let i=0;i<peaks.length;i++){const p=peaks[i]; const x=i; const y1=mid+p[0]*mid; const y2=mid+p[1]*mid; ctx.moveTo(x,y1); ctx.lineTo(x,y2);} ctx.stroke();
  ctx.fillStyle='rgba(255,255,255,.6)'; ctx.font=`${12*devicePixelRatio}px ui-monospace,monospace`; ctx.fillText(`${fmt(viewOffsetSec)} ~ ${fmt(viewOffsetSec+Number(waveCanvas.dataset.dur||0))}`,16,16);
  if(selection.active){const dur=Number(waveCanvas.dataset.dur||0); const x1=(Math.max(0,selection.start-viewOffsetSec)/dur)*waveCanvas.width/devicePixelRatio; const x2=(Math.max(0,selection.end-viewOffsetSec)/dur)*waveCanvas.width/devicePixelRatio; selEl.style.left=Math.min(x1,x2)+'px'; selEl.style.width=Math.abs(x2-x1)+'px';} else selEl.style.width=0;
}

function buildPeaks(viewDur=winSec,offset=viewOffsetSec){
  if(!buffer)return; const sr=buffer.sampleRate; const startFrame=Math.floor(offset*sr); const endFrame=Math.floor(Math.min(buffer.duration,offset+viewDur)*sr); const step=Math.max(1, Math.floor((endFrame-startFrame)/waveCanvas.width)); const ch=buffer.getChannelData(0); peaks=[]; for(let i=0;i<waveCanvas.width;i++){const s=startFrame+i*step; let min=1,max=-1; for(let j=0;j<step;j++){const v=ch[s+j]||0; if(v<min)min=v; if(v>max)max=v;} peaks.push([min,max]);} waveCanvas.dataset.dur=viewDur; draw();}

async function decode(file){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); const arr=await file.arrayBuffer(); buffer=await audioCtx.decodeAudioData(arr); }

fileInput.addEventListener('change',async e=>{
  const f=e.target.files[0]; if(!f)return; await decode(f);
  viewOffsetSec=0; winSec=Number(winSecInput.value)||600;
  info.textContent=`${f.name} ｜ 总长 ${fmt(buffer.duration)}`;
  initHeatmapArrays(); await ensureLoudnessForRange(0, Math.min(buffer.duration, winSec*2));
  buildPeaks(winSec,viewOffsetSec);
  playBtn.disabled=false; exportWavBtn.disabled=false; exportMp3Btn.disabled=false; prevBtn.disabled=false; nextBtn.disabled=false; prevTalkBtn.disabled=false; nextTalkBtn.disabled=false; drawHeatmap();
});

function initHeatmapArrays(){ const buckets=Math.ceil(buffer.duration/5); loudness=new Array(buckets).fill(0); loudKnown=new Array(buckets).fill(false); }
async function ensureLoudnessForRange(startSec,endSec){ const sr=buffer.sampleRate; const ch=buffer.getChannelData(0); const b0=Math.max(0,Math.floor(startSec/5)); const b1=Math.min(loudness.length-1,Math.ceil(endSec/5)); for(let bi=b0; bi<=b1; bi++){ if(loudKnown[bi]) continue; const s=Math.floor(bi*5*sr); const e=Math.min(ch.length, Math.floor((bi+1)*5*sr)); let sum=0; for(let i=s;i<e;i++){ const v=ch[i]; sum+=v*v; } loudness[bi]=Math.sqrt(sum/Math.max(1,e-s)); loudKnown[bi]=true; } }

function drawHeatmap(){ const g=heatmapCanvas.getContext('2d'); g.clearRect(0,0,heatmapCanvas.width,heatmapCanvas.height); if(!buffer) return; const W=heatmapCanvas.width, H=heatmapCanvas.height; const n=loudness.length||1; for(let i=0;i<n;i++){ const x=i/n*W; const w=Math.ceil(W/n); const v=loudness[i]; const known=loudKnown[i]; const c=!known? 'rgba(148,163,184,.25)' : `hsl(${Math.max(0,200-200*Math.min(1,v/0.15))} 80% 50%)`; g.fillStyle=c; g.fillRect(x,0,w,H);} if(buffer){ const sx=(viewOffsetSec/buffer.duration)*W; const ex=((viewOffsetSec+Math.min(winSec, buffer.duration))/buffer.duration)*W; g.strokeStyle='#22c55e'; g.lineWidth=2; g.strokeRect(sx,1,Math.max(2,ex-sx),H-2);} }

heatmapCanvas.addEventListener('click', async (e)=>{ if(!buffer) return; const rect=heatmapCanvas.getBoundingClientRect(); const ratio=(e.clientX-rect.left)/rect.width; const t=Math.max(0, Math.min(buffer.duration-1, ratio*buffer.duration)); viewOffsetSec=Math.max(0, Math.min(buffer.duration-Math.min(winSec,buffer.duration), t - winSec/2)); await ensureLoudnessForRange(viewOffsetSec, viewOffsetSec+winSec); buildPeaks(winSec, viewOffsetSec); drawHeatmap(); });

prevBtn.addEventListener('click', async ()=>{ viewOffsetSec=Math.max(0,viewOffsetSec-winSec); await ensureLoudnessForRange(viewOffsetSec, viewOffsetSec+winSec); buildPeaks(winSec,viewOffsetSec); drawHeatmap(); });
nextBtn.addEventListener('click', async ()=>{ viewOffsetSec=Math.min(Math.max(0,buffer.duration-winSec),viewOffsetSec+winSec); await ensureLoudnessForRange(viewOffsetSec, viewOffsetSec+winSec); buildPeaks(winSec,viewOffsetSec); drawHeatmap(); });

function findTalk(startBucket, dir){ const step=dir>0?1:-1; const minDurSec=Math.max(5, Math.min(60, Number(minDurInput.value)||15)); const needBuckets=Math.ceil(minDurSec/5); const th=Math.max(0, Math.min(0.2, Number(thInput.value)||0.08)); for(let i=startBucket; i>=0 && i<loudness.length; i+=step){ let ok=true; for(let k=0;k<needBuckets;k++){ const idx=i+k*step; if(idx<0||idx>=loudness.length){ ok=false; break; } if(!loudKnown[idx]){ ok=false; break; } if(loudness[idx] < th){ ok=false; break; } } if(ok) return i; } return -1; }

prevTalkBtn.addEventListener('click', async ()=>{ const curBucket=Math.floor(viewOffsetSec/5); // 确保邻域已计算
 await ensureLoudnessForRange(Math.max(0,(curBucket-60)*5), (curBucket+5)*5);
 const idx=findTalk(curBucket-1,-1); if(idx>=0){ viewOffsetSec=Math.max(0, idx*5); await ensureLoudnessForRange(viewOffsetSec, viewOffsetSec+winSec); buildPeaks(winSec,viewOffsetSec); drawHeatmap(); } });
nextTalkBtn.addEventListener('click', async ()=>{ const curBucket=Math.floor((viewOffsetSec+winSec)/5); await ensureLoudnessForRange(curBucket*5, Math.min(buffer.duration,(curBucket+60)*5)); const idx=findTalk(curBucket+1,1); if(idx>=0){ viewOffsetSec=Math.min(Math.max(0, buffer.duration-winSec), idx*5); await ensureLoudnessForRange(viewOffsetSec, viewOffsetSec+winSec); buildPeaks(winSec,viewOffsetSec); drawHeatmap(); } });

winSecInput.addEventListener('change', async ()=>{ winSec=Math.max(10,Math.min(1800,Number(winSecInput.value)||600)); await ensureLoudnessForRange(viewOffsetSec, viewOffsetSec+winSec); buildPeaks(winSec,viewOffsetSec); drawHeatmap(); });

// 播放（仅当前窗口）
playBtn.addEventListener('click',()=>{ if(!buffer)return; if(srcNode){ try{srcNode.stop();}catch{} try{srcNode.disconnect();}catch{} srcNode=null; playBtn.textContent='▶️ 播放/暂停'; return; } if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); srcNode=audioCtx.createBufferSource(); srcNode.buffer=buffer; srcNode.connect(audioCtx.destination); srcNode.start(0, viewOffsetSec, Math.min(winSec, buffer.duration-viewOffsetSec)); playBtn.textContent='⏸️ 暂停'; srcNode.onended=()=>{ srcNode=null; playBtn.textContent='▶️ 播放/暂停'; }; });

function getWindowData(){ const a=viewOffsetSec; const b=Math.min(buffer.duration, viewOffsetSec + (Number(waveCanvas.dataset.dur)||winSec)); const sr=buffer.sampleRate; const startFrame=Math.floor(a*sr); const endFrame=Math.floor(b*sr); const ch=buffer.getChannelData(0).subarray(startFrame,endFrame); return {channels:[ch],sampleRate:sr,start:a,end:b}; }

function wavEncode({channels,sampleRate}){ const numFrames=channels[0].length; const buf=new ArrayBuffer(44+numFrames*2); const view=new DataView(buf); function ws(o,s){ for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); } ws(0,'RIFF'); view.setUint32(4,36+numFrames*2,true); ws(8,'WAVE'); ws(12,'fmt '); view.setUint32(16,16,true); view.setUint16(20,1,true); view.setUint16(22,1,true); view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*2,true); view.setUint16(32,2,true); view.setUint16(34,16,true); ws(36,'data'); view.setUint32(40,numFrames*2,true); let offset=44; for(let i=0;i<numFrames;i++){ let s=channels[0][i]; s=Math.max(-1,Math.min(1,s)); view.setInt16(offset, s<0?s*0x8000:s*0x7FFF, true); offset+=2; } return new Blob([buf],{type:'audio/wav'}); }

exportWavBtn.addEventListener('click',()=>{ const data=getWindowData(); const blob=wavEncode(data); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`window_${fmt(data.start)}-${fmt(data.end)}.wav`; a.click(); });

exportMp3Btn.addEventListener('click',async()=>{ const data=getWindowData(); if(!window.lamejs){ await new Promise(res=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js'; s.onload=res; document.head.appendChild(s); }); } const enc=new lamejs.Mp3Encoder(1,data.sampleRate,128); const s16=new Int16Array(data.channels[0].length); for(let i=0;i<s16.length;i++){ let v=Math.max(-1,Math.min(1,data.channels[0][i])); s16[i]=v<0?v*0x8000:v*0x7FFF; } const block=1152,mp3=[]; for(let i=0;i<s16.length;i+=block){ const chunk=enc.encodeBuffer(s16.subarray(i,i+block)); if(chunk.length) mp3.push(chunk); } const end=enc.flush(); if(end.length) mp3.push(end); const blob=new Blob(mp3,{type:'audio/mpeg'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`window_${fmt(data.start)}-${fmt(data.end)}.mp3`; a.click(); });
</script>
</body>
</html>

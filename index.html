<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>本地音频剪裁工具｜波形选段导出</title>
  <style>
    :root{
      --bg:#0f172a;--panel:#111827;--muted:#6b7280;--accent:#22c55e;--accent-2:#3b82f6;--text:#e5e7eb;--danger:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1020,#0a0f1f);color:var(--text);font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Noto Sans CJK SC","Microsoft Yahei",sans-serif}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    .card{background:rgba(255,255,255,0.04);backdrop-filter: blur(6px);border:1px solid rgba(255,255,255,.08);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .head{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.08)}
    .head h1{font-size:18px;margin:0;font-weight:700}
    .controls{display:flex;flex-wrap:wrap;gap:8px}
    input[type=file]{display:none}
    .btn{appearance:none;border:none;border-radius:12px;padding:10px 14px;color:#fff;background:#1f2937;cursor:pointer;transition:.2s ease;display:inline-flex;gap:8px;align-items:center}
    .btn:hover{filter:brightness(1.15)}
    .btn.primary{background:linear-gradient(180deg,var(--accent),#179d48)}
    .btn.blue{background:linear-gradient(180deg,var(--accent-2),#2563eb)}
    .btn.danger{background:linear-gradient(180deg,var(--danger),#b91c1c)}
    .btn.ghost{background:transparent;outline:1px solid rgba(255,255,255,.15)}
    .btn:disabled{opacity:.55;cursor:not-allowed}
    .body{padding:16px}
    .canvas-wrap{position:relative;border-radius:14px;overflow:hidden;border:1px solid rgba(255,255,255,.08);background:#0a0f1c}
    canvas{display:block;width:100%;height:180px}
    .timeline{position:absolute;inset:0;pointer-events:none}
    .info{display:grid;grid-template-columns: repeat(6,minmax(0,1fr));gap:12px;margin-top:12px}
    .stat{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px}
    .stat small{display:block;color:var(--muted);font-size:12px}
    .stat b{font-size:16px}
    .footer{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between;margin-top:14px}
    .range{display:flex;gap:8px;align-items:center}
    input[type=range]{width:200px}
    .kbd{font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,monospace;color:#cbd5e1;background:#0b1220;border:1px solid rgba(255,255,255,.1);padding:3px 6px;border-radius:8px}
    .hint{color:#a1a1aa}
    .progress{position:absolute;left:0;top:0;height:100%;width:0;background:rgba(56,189,248,.08);pointer-events:none}
    .sel{position:absolute;top:0;height:100%;left:0;width:0;background:rgba(34,197,94,.18);outline:1px dashed rgba(34,197,94,.9);pointer-events:none}
  </style>
</head>
<body>
  <div class="wrap card">
    <div class="head">
      <h1>本地音频剪裁工具 <span style="opacity:.6">｜波形选段、导出WAV</span></h1>
      <div class="controls">
        <label class="btn blue" for="fileInput">📂 载入音频</label>
        <input id="fileInput" type="file" accept=".mp3,audio/mpeg,audio/*" />
        <button id="playBtn" class="btn" disabled>▶️ 播放</button>
        <button id="stopBtn" class="btn ghost" disabled>⏹️ 停止</button>
        <button id="loopBtn" class="btn ghost" disabled>🔁 循环关</button>
        <button id="fitBtn" class="btn ghost" disabled>🧭 适配波形</button>
        <button id="zoomInBtn" class="btn ghost" disabled>➕ 放大</button>
        <button id="zoomOutBtn" class="btn ghost" disabled>➖ 缩小</button>
        <button id="resetSelBtn" class="btn ghost" disabled>🧹 清除选区</button>
        <button id="exportBtn" class="btn primary" disabled>⬇️ 导出选段 (WAV)</button>
      </div>
    </div>
    <div class="body">
      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="wave"></canvas>
        <div class="progress" id="playhead"></div>
        <div class="sel" id="selection"></div>
        <canvas class="timeline" id="grid"></canvas>
      </div>
      <div class="info">
        <div class="stat"><small>文件名</small><b id="fileName">—</b></div>
        <div class="stat"><small>采样率</small><b id="sampleRate">—</b></div>
        <div class="stat"><small>声道数</small><b id="channels">—</b></div>
        <div class="stat"><small>时长</small><b id="duration">—</b></div>
        <div class="stat"><small>选择开始</small><b id="selStart">—</b></div>
        <div class="stat"><small>选择结束</small><b id="selEnd">—</b></div>
      </div>
      <div class="footer">
        <div class="hint">提示：拖动波形即可框选；<span class="kbd">Space</span> 播放/暂停，<span class="kbd">Ctrl/Cmd+E</span> 导出选段。</div>
        <div class="range">
          <span>缩放：</span>
          <input id="zoomRange" type="range" min="1" max="10" step="1" value="1" disabled />
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const waveCanvas = document.getElementById('wave');
  const gridCanvas = document.getElementById('grid');
  const wrap = document.getElementById('canvasWrap');
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const loopBtn = document.getElementById('loopBtn');
  const exportBtn = document.getElementById('exportBtn');
  const fitBtn = document.getElementById('fitBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetSelBtn = document.getElementById('resetSelBtn');
  const zoomRange = document.getElementById('zoomRange');
  const playheadEl = document.getElementById('playhead');
  const selEl = document.getElementById('selection');

  const fileNameEl = document.getElementById('fileName');
  const srEl = document.getElementById('sampleRate');
  const chEl = document.getElementById('channels');
  const durEl = document.getElementById('duration');
  const selStartEl = document.getElementById('selStart');
  const selEndEl = document.getElementById('selEnd');

  let audioCtx; // AudioContext
  let buffer;   // AudioBuffer
  let srcNode;  // BufferSourceNode
  let playing = false;
  let loop = false;

  let zoom = 1;      // 1..10
  let offset = 0;    // px scroll offset in waveform (for future horizontal scroll; kept 0 now)
  let peaks = [];    // downsampled peaks

  let selection = {active:false, start:0, end:0}; // seconds

  const dpr = Math.max(1, window.devicePixelRatio || 1);

  function fmt(t){
    if (!isFinite(t)) return '—';
    const sign = t < 0 ? '-' : '';
    t = Math.max(0, t);
    const m = Math.floor(t/60);
    const s = Math.floor(t%60);
    const ms = Math.floor((t*1000)%1000);
    return `${sign}${m}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
  }

  function enableUI(enabled){
    [playBtn, stopBtn, loopBtn, exportBtn, fitBtn, zoomInBtn, zoomOutBtn, resetSelBtn, zoomRange].forEach(b=>b.disabled=!enabled);
  }

  function resize(){
    const rect = wrap.getBoundingClientRect();
    [waveCanvas, gridCanvas].forEach(cv=>{
      cv.width = Math.floor(rect.width * dpr);
      cv.height = Math.floor(180 * dpr);
      cv.style.width = rect.width + 'px';
      cv.style.height = '180px';
    });
    draw();
  }
  window.addEventListener('resize', resize);

  async function loadFile(file){
    stop();
    try{
      const arr = await file.arrayBuffer();
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      // iOS/Safari needs a user-gesture-resume just in case
      if (audioCtx.state === 'suspended') { try{ await audioCtx.resume(); }catch(e){} }

      // Safari compatibility: some versions fail the promise-form of decodeAudioData for MP3.
      // We try promise first, then fallback to callback API.
      const tryPromiseDecode = () => audioCtx.decodeAudioData(arr.slice(0));
      const tryCallbackDecode = () => new Promise((resolve, reject)=>{
        audioCtx.decodeAudioData(arr.slice(0), resolve, reject);
      });

      try{
        buffer = await tryPromiseDecode();
      }catch(err){
        try{ buffer = await tryCallbackDecode(); }
        catch(err2){
          console.error('decodeAudioData failed', err2);
          throw new Error('无法解码该音频。若为 Apple Music/受 DRM 保护的文件将不可导入；请先将 MP3 存到“文件”App并完整下载到本地后再试。');
        }
      }

      fileNameEl.textContent = file.name;
      srEl.textContent = buffer.sampleRate + ' Hz';
      chEl.textContent = buffer.numberOfChannels;
      durEl.textContent = fmt(buffer.duration);
      buildPeaks();
      selection = {active:false,start:0,end:0};
      updateSelInfo();
      enableUI(true);
      resize();
    }catch(e){
      console.error(e);
      alert(e.message || '加载失败：该音频类型在此设备上不受支持。请尝试转换为 WAV/MP3（无 DRM）后再导入。');
      enableUI(false);
    }
  }

  function buildPeaks(){
    // Downsample to ~2 px per sample (per dpr) for speed; granularity depends on zoom
    const width = waveCanvas.width; // in device px
    const samplesPerBucket = Math.max(1, Math.floor(buffer.length / width));
    const ch0 = buffer.getChannelData(0);
    const ch1 = buffer.numberOfChannels>1 ? buffer.getChannelData(1) : null;
    peaks = new Array(width);
    for (let i=0;i<width;i++){
      const start = i*samplesPerBucket;
      const end = Math.min((i+1)*samplesPerBucket, ch0.length);
      let min=1, max=-1;
      for (let j=start;j<end;j++){
        const vL = ch0[j];
        const vR = ch1 ? ch1[j] : vL;
        const v = (vL + vR) * 0.5; // average stereo
        if (v<min) min=v; if (v>max) max=v;
      }
      peaks[i] = [min, max];
    }
  }

  function secToX(sec){
    const total = buffer?buffer.duration:1;
    const rectW = waveCanvas.width;
    return (sec/total) * rectW;
  }
  function xToSec(x){
    const total = buffer?buffer.duration:1;
    const rectW = waveCanvas.width;
    return (x/rectW) * total;
  }

  function draw(){
    const ctx = waveCanvas.getContext('2d');
    ctx.clearRect(0,0,waveCanvas.width,waveCanvas.height);
    // background
    ctx.fillStyle = '#0b1020';
    ctx.fillRect(0,0,waveCanvas.width,waveCanvas.height);

    if (!buffer || !peaks.length){ drawGrid(); return; }

    // waveform
    const mid = waveCanvas.height/2;
    ctx.strokeStyle = 'rgba(148,163,184,.9)';
    ctx.beginPath();
    for (let x=0;x<peaks.length;x+=Math.max(1,Math.floor(2/zoom))){
      const p = peaks[x];
      const y1 = mid + p[0]*mid*0.95;
      const y2 = mid + p[1]*mid*0.95;
      ctx.moveTo(x+0.5, y1);
      ctx.lineTo(x+0.5, y2);
    }
    ctx.stroke();

    drawGrid();

    // selection overlay (handled via CSS element for crispness) -> updated in updateSelectionOverlay
    updateSelectionOverlay();
  }

  function drawGrid(){
    const g = gridCanvas.getContext('2d');
    g.clearRect(0,0,gridCanvas.width,gridCanvas.height);
    if (!buffer) return;
    const dur = buffer.duration;
    const w = gridCanvas.width; const h = gridCanvas.height; const mid = h/2;

    g.fillStyle = 'rgba(255,255,255,.03)';
    for (let i=0;i<5;i++){
      const y = (i/4)*h; g.fillRect(0, y, w, 1);
    }

    // time ticks every ~0.5s based on width
    const pxPerSec = w/dur;
    const major = Math.max(1, Math.round(100/pxPerSec)); // ensure readable spacing
    const minor = major/2;

    g.fillStyle = 'rgba(255,255,255,.08)';
    g.strokeStyle = 'rgba(255,255,255,.12)';
    g.font = `${12*dpr}px ui-monospace,monospace`;
    g.textBaseline = 'top'; g.fillStyle = 'rgba(200,200,220,.8)';

    for (let s=0; s<=dur; s+=major){
      const x = Math.floor(s*pxPerSec)+0.5;
      g.strokeStyle='rgba(255,255,255,.12)';
      g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke();
      const label = fmt(s).replace(/^[^:]+:/,''); // show SS.mmm
      g.fillText(label, x+4, 4);
    }
  }

  function updateSelectionOverlay(){
    if (!buffer) { selEl.style.width = '0px'; return; }
    if (!selection.active) { selEl.style.width = '0px'; return; }
    const x1 = secToX(selection.start)/dpr;
    const x2 = secToX(selection.end)/dpr;
    selEl.style.left = Math.min(x1,x2)+ 'px';
    selEl.style.width = Math.max(1, Math.abs(x2-x1)) + 'px';
  }

  function updateSelInfo(){
    selStartEl.textContent = selection.active? fmt(Math.min(selection.start, selection.end)) : '—';
    selEndEl.textContent   = selection.active? fmt(Math.max(selection.start, selection.end)) : '—';
    exportBtn.disabled = !selection.active || !buffer;
    resetSelBtn.disabled = !selection.active;
  }

  // Mouse/touch selection
  let dragging = false;
  function onDown(clientX){
    if (!buffer) return;
    dragging = true; selection.active=true;
    const rect = waveCanvas.getBoundingClientRect();
    const x = (clientX - rect.left) * dpr;
    selection.start = xToSec(x);
    selection.end = selection.start;
    updateSelInfo(); draw();
  }
  function onMove(clientX){
    if (!dragging || !buffer) return;
    const rect = waveCanvas.getBoundingClientRect();
    const x = (clientX - rect.left) * dpr;
    selection.end = Math.min(buffer.duration, Math.max(0, xToSec(x)));
    updateSelInfo(); draw();
  }
  function onUp(){ dragging = false; }

  waveCanvas.addEventListener('mousedown', e=> onDown(e.clientX));
  window.addEventListener('mousemove', e=> onMove(e.clientX));
  window.addEventListener('mouseup', onUp);
  waveCanvas.addEventListener('touchstart', e=>{ if(e.touches[0]) onDown(e.touches[0].clientX);});
  window.addEventListener('touchmove', e=>{ if(e.touches[0]) onMove(e.touches[0].clientX);});
  window.addEventListener('touchend', onUp);

  // Playback
  let playStartTime = 0; // context time when started
  let playStartOffset = 0; // seconds into buffer when started

  function startNode(offsetSec, durationSec){
    stop();
    srcNode = audioCtx.createBufferSource();
    srcNode.buffer = buffer;
    srcNode.connect(audioCtx.destination);
    srcNode.loop = loop && selection.active;
    if (srcNode.loop){
      const a = Math.min(selection.start, selection.end);
      const b = Math.max(selection.start, selection.end);
      srcNode.loopStart = a;
      srcNode.loopEnd = b;
      srcNode.start(0, a);
      playStartOffset = a;
    } else {
      srcNode.start(0, offsetSec || 0, durationSec||undefined);
      playStartOffset = offsetSec||0;
    }
    playStartTime = audioCtx.currentTime;
    playing = true;
    playBtn.textContent = '⏸️ 暂停';
    rafPlayhead();
    srcNode.onended = ()=>{ if(!srcNode) return; if(!srcNode.loop){ playing=false; playBtn.textContent='▶️ 播放'; updatePlayhead(0); }};
  }

  function play(){
    if (!buffer) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (playing) { pause(); return; }
    if (selection.active){
      const a = Math.min(selection.start, selection.end);
      const b = Math.max(selection.start, selection.end);
      startNode(a, b-a);
    } else {
      startNode(0);
    }
  }

  function pause(){
    if (!playing) return;
    // capture current offset
    const elapsed = audioCtx.currentTime - playStartTime;
    playStartOffset += elapsed;
    stop(true);
    playing = false;
    playBtn.textContent = '▶️ 播放';
  }

  function stop(keepOffset=false){
    if (srcNode){
      try{ srcNode.stop(); }catch(e){}
      try{ srcNode.disconnect(); }catch(e){}
    }
    srcNode = null;
    if (!keepOffset){ playStartOffset = 0; }
    playBtn.textContent = '▶️ 播放';
    playing = false;
    updatePlayhead(0);
  }

  function updatePlayhead(forcedX){
    if (!buffer){ playheadEl.style.width='0px'; return; }
    let curSec;
    if (playing){
      const elapsed = audioCtx.currentTime - playStartTime;
      curSec = (playStartOffset + elapsed) % buffer.duration;
    } else {
      curSec = selection.active ? Math.min(selection.end, buffer.duration) : 0;
    }
    const x = forcedX || (secToX(curSec)/dpr);
    playheadEl.style.width = Math.max(0, Math.min(x, waveCanvas.clientWidth)) + 'px';
  }

  function rafPlayhead(){
    if (!playing) return;
    updatePlayhead();
    requestAnimationFrame(rafPlayhead);
  }

  // Export WAV
  function exportSelection(){
    if (!buffer || !selection.active) return;
    const a = Math.max(0, Math.min(selection.start, selection.end));
    const b = Math.max(0, Math.min(buffer.duration, Math.max(selection.start, selection.end)));
    const sr = buffer.sampleRate;
    const startFrame = Math.floor(a*sr);
    const endFrame = Math.floor(b*sr);
    const frameCount = Math.max(0, endFrame - startFrame);
    const ch = buffer.numberOfChannels;

    // Create new Float32 arrays per channel
    const channels = [];
    for (let c=0;c<ch;c++){
      const src = buffer.getChannelData(c);
      const slice = new Float32Array(frameCount);
      slice.set(src.subarray(startFrame, endFrame));
      channels.push(slice);
    }

    const wav = encodeWAVFromFloat32(channels, sr);
    const blob = new Blob([wav], {type:'audio/wav'});
    const url = URL.createObjectURL(blob);

    const aEl = document.createElement('a');
    const base = (document.getElementById('fileName').textContent||'audio').replace(/\.[^/.]+$/,'');
    aEl.download = `${base}_${fmt(a).replace(/[:.]/g,'')}-${fmt(b).replace(/[:.]/g,'')}.wav`;
    aEl.href = url; aEl.click();
    setTimeout(()=> URL.revokeObjectURL(url), 10000);
  }

  function encodeWAVFromFloat32(channels, sampleRate){
    // PCM 16-bit little-endian
    const numChannels = channels.length;
    const numFrames = channels[0].length;
    const bytesPerSample = 2;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = numFrames * blockAlign;
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);

    function writeStr(off, str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }

    // RIFF header
    writeStr(0,'RIFF');
    view.setUint32(4, 36 + dataSize, true);
    writeStr(8,'WAVE');

    // fmt chunk
    writeStr(12,'fmt ');
    view.setUint32(16, 16, true); // PCM chunk size
    view.setUint16(20, 1, true);  // PCM format
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true); // bits per sample

    // data chunk
    writeStr(36,'data');
    view.setUint32(40, dataSize, true);

    // Interleave and write samples
    let offset = 44;
    for (let i=0; i<numFrames; i++){
      for (let ch=0; ch<numChannels; ch++){
        let s = channels[ch][i];
        s = Math.max(-1, Math.min(1, s));
        const v = s < 0 ? s * 0x8000 : s * 0x7FFF; // 16-bit signed
        view.setInt16(offset, v, true); offset += 2;
      }
    }
    return view;
  }

  // Events
  fileInput.addEventListener('change', async e=>{
    const f = e.target.files[0]; if (!f) return;
    // iOS 针对性提示：从“文件”App 选择、确保不是 Apple Music 的受保护音频
    await loadFile(f);
  });
  });
  playBtn.addEventListener('click', play);
  stopBtn.addEventListener('click', ()=> stop());
  exportBtn.addEventListener('click', exportSelection);
  loopBtn.addEventListener('click', ()=>{
    loop = !loop; loopBtn.textContent = loop? '🔁 循环开' : '🔁 循环关';
    if (srcNode) { srcNode.loop = loop && selection.active; }
  });
  fitBtn.addEventListener('click', ()=>{ zoom = 1; zoomRange.value=1; draw(); });
  zoomInBtn.addEventListener('click', ()=>{ zoom = Math.min(10, zoom+1); zoomRange.value=zoom; draw(); });
  zoomOutBtn.addEventListener('click', ()=>{ zoom = Math.max(1, zoom-1); zoomRange.value=zoom; draw(); });
  resetSelBtn.addEventListener('click', ()=>{ selection={active:false,start:0,end:0}; updateSelInfo(); draw(); });
  zoomRange.addEventListener('input', e=>{ zoom = +e.target.value; draw(); });

  // Keyboard
  window.addEventListener('keydown', e=>{
    if (e.code==='Space'){ e.preventDefault(); play(); }
    if ((e.ctrlKey||e.metaKey) && (e.key==='e'||e.key==='E')){ e.preventDefault(); exportSelection(); }
  });

  // Initial
  enableUI(false);
  resize();
})();
</script>
</body>
</html>
